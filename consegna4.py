# -*- coding: utf-8 -*-
"""Consegna4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1byVlH4_ean2sfMnQlYD8a0o0PD9zpWO9
"""

import numpy as np
import pandas as pd
import os.path as p

def gradientDescent(X, y, theta, alpha, iters):
	temp = np.matrix(np.zeros(theta.shape))
	parameters = int(theta.ravel().shape[1])
	cost = np.zeros(iters)

	for i in range(iters):
		error = (X * theta.T) - y

		for j in range(parameters):
			term = np.multiply(error, X[:,j])
			temp[0,j] = theta[0,j] - ((alpha / len(X)) * np.sum(term))

		theta = temp
		cost[i] = computeCost(X, y, theta)

	return theta, cost

def computeCost(X, y, theta):
	inner = np.power(((X * theta.T) - y), 2)
	return np.sum(inner) / (2 * len(X))


def linear_regr(dataset,value):

  if not p.isfile(dataset):
    return None

  data = pd.read_csv(dataset, header=0, delimiter=',', names=['x', 'y'])

  #inizializzazione paramteri learning rate and iterazioni
  alpha = 0.01
  iters = 1000

  # impostazione di X matrice dei pattern e di y vettore delle variabili dipendenti
  data.insert(0, 'Ones', 1)
  cols = data.shape[1]
  X = data.iloc[:,0:cols-1]
  y = data.iloc[:,cols-1:cols]

  #conversione in matrici elaborabili da numpy
  X = np.matrix(X.values)
  y = np.matrix(y.values)
  theta = np.matrix(np.array([0,0]))

  g, cost = gradientDescent(X, y, theta, alpha, iters)

  return g[0, 0] + (g[0, 1] * value)

print(linear_regr('/content/sample_data/day_mod.csv',0.22))
print(linear_regr('/content/sample_data/day_od.csv',0.22))
print(linear_regr('ple_data/day_od.csv',0.22))
print(linear_regr('pippo',0.22))

#esercizio 2 vecchioooooooooooo
'''
def vertical_stack1(a,b):
  
  #conversione delle liste python in array numpy
  a=np.asarray(a)
  b=np.asarray(b)

  #se sono in dimensione 1 sono vettori colonna qundi va detto che la forma è 1 riga 3 colonne
  if len(a.shape)==1:
    a=a.reshape(1,a.shape[0])

  if len(b.shape)==1:
    b=b.reshape(1,b.shape[0])

  #se non hanno lo stesso numero di colonne allora non si possono concatenare
  if a.shape[1] != b.shape[1]:
    return np.asarray([])

  #con qualsisi altra dimensione
  return np.concatenate((a,b),axis=0)

print(vertical_stack1(np.array([1,2,3]),np.array([7,8,9])))
print()
print(vertical_stack1([1,2,3],[7,8,9]))
print()
#vertical_stack(np.array([1,2,3]),np.array([[7,8,9],[3,3,3]])) 
print(vertical_stack1(np.array([[1,2,3],[2,2,2]]),np.array([[7,8,9],[3,3,3]])))
print()
print(vertical_stack1([[1,2,3],[2,2,2]],[[7,8,9],[3,3,3]]))
print()
print(vertical_stack1([[1,2,3],[2,2,2],[4,4,4]],[[7,8,9],[3,3,3]]))
print()
print(vertical_stack1([[1,2],[2,2],[4,4]],[[7,8,9],[3,3,3]]))
#controlli di casi limite vanno messi? tipo array con dimensioni di colonne differenti
#print(vertical_stack(np.array([1,2]),np.array([7,8,9])))
'''

#esercizio 3

def match(a,b):

  #conversione delle liste python in array numpy
  a=np.asarray(a)
  b=np.asarray(b)

  #se sono monodimensionali si convertono da vettori colonna a vettori riga
  if len(a.shape)==1:
    a=a.reshape(1,a.shape[0])

  if len(b.shape)==1:
    b=b.reshape(1,b.shape[0])

  #se sono su più righe
  if a.shape[0]>1 or b.shape[0]>1:
    return None

  result=[]
  #confronto solo array con la stessa shape
  if a.shape[0]==b.shape[0] and a.shape[1] == b.shape[1]:
    for i in range(a.shape[1]):
        if a[0][i]==b[0][i]:
          result.append(i)
  else:
    return None

  return np.asarray(result)

#senza print torna un numpy array
print(match(np.array([1,8,6,3,5,6,4,6,1,7]),np.array([8,8,6,1,2,6,4,3,0,2])))
print()
print(match([1,8,6,3,5,6,4,6,1,7],[8,8,6,1,2,6,4,3,0,2]))
print()
print(match([1,8,6,3,5,6,4,6,1,7],[8,8,6,1,2,6,4]))
print()
print(match([1,1,2,2,3,3,4,4,5,5],[8,8,6,1,2,6,4,3,0,2]))
print()
print(match([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10]))
print()
print(match([[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10]],[1,2,3,4,5,6,7,8,9,10]))
print()
print(match([[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10]],[[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10]]))
print()
print(match([],[]))

#alternativa es 2

def vertical_stack(a,b):#<----------SE CONSEGNI QUESTA CAMBIA IL NOME NEL NOME CORRETTO--------------

  a=np.asarray(a)
  b=np.asarray(b)

  if a.shape!=b.shape:
    return None
  
  return np.vstack((a,b))

print(vertical_stack(np.array([1,8,6,3,5,6,4,6,1,7]),np.array([8,8,6,1,2,6,4,3,0,2])))
print()
print(vertical_stack([1,8,6,3,5,6,4,6,1,7],[8,8,6,1,2,6,4,3,0,2]))
print()
print(vertical_stack([1,8,6,3,5,6,4,6,1,7],[8,8,6,1,2,6,4]))
print()
print(vertical_stack([1,1,2,2,3,3,4,4,5,5],[8,8,6,1,2,6,4,3,0,2]))
print()
print(vertical_stack([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10]))
print()
print(vertical_stack(np.array([[1,2,3],[2,2,2]]),np.array([[7,8,9],[3,3,3]])))
print()
print(vertical_stack([[1,2,3],[2,2,2],[4,4,4]],[[7,8,9],[3,3,3]]))
print()
print(vertical_stack([[1,2],[2,2],[4,4]],[[7,8,9],[3,3,3]]))
print()
print(vertical_stack([],[]))

